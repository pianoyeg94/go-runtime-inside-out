package hpack

// building partial huffman tree only for:
//
//	0x0AHello World!0x88 (to encode)
//	0x0A = 10, 0x88 = 136 (symbols)
func buildRootHuffmanNodeExample() {
	// TODO: add photos
}

// 0x0AHello World!0x88 (to encode)
// 0x0A = 10, 0x88 = 136 (symbols)
func AppendHuffmanStringExample(dst []byte, s string) []byte {
	// This relies on the maximum huffman code length being 30 (See tables.go huffmanCodeLen array)
	// So if a uint64 buffer has less than 32 valid bits can always accommodate another huffmanCode.
	var (
		// buffer which can accommodate minimum 2 huffman codes
		// huffman encoded characters are appended to destination in 32 bit batches
		// if their are more than 32 valid bits in buffer, the rest will go into the next 32 bit batch
		x uint64
		// number of valid bits present in x
		// (bits of the buffered huffman codes for a 32 bit batch)
		n uint
	)
	// ===========================================================================================================================
	// ------------------------+
	// 0x0A                   |
	// ------------------------+

	c := byte(0x0A)
	n += uint(huffmanCodeLen[c]) // n += 30, n = 30
	x <<= huffmanCodeLen[c] % 64 // x <<= 30 =        |00000000|00000000|00000000|00000000|00000000|00000000|00000000|000000000|
	x |= uint64(huffmanCodes[c]) // x |= 0x3ffffffc = |00|00000000|00000000|00000000|00000000|11111111|11111111|11111111|111100|
	//                                                                                       |  valid bits present in x (30)   |
	if n >= 32 { //                 false
	}

	// ===========================================================================================================================
	// ------------------------+
	// 'H'                     |
	// ------------------------+

	c = byte('H')
	n += uint(huffmanCodeLen[c]) // n += 7, n = 37
	x <<= huffmanCodeLen[c] % 64 // x <<= 7 =         |000|00000000|00000000|00000000|11111111|11111111|11111111|11110000|00000|
	x |= uint64(huffmanCodes[c]) // x |= 0x63 =       |000|00000000|00000000|00000000|11111111|11111111|11111111|11110011|00011|
	//                                                                               |  valid bits present in x (37)           |
	if n >= 32 { //                 true
		n %= 32             //      n = 5
		y := uint32(x >> n) //      uint32(x >> 5) = 4 byte batch                    |11111111|11111111|11111111|11110011|
		dst = append(dst, byte(y>>24), byte(y>>16), byte(y>>8), byte(y))
		//                          dst =                                            |11111111|11111111|11111111|11110011|

	}

	// ===========================================================================================================================
	// ------------------------+
	// 'e'                     |
	// ------------------------+
	n = 5            //             left over valid bits of huffman code
	x = 0x1ffffffe63 //                               |000|00000000|00000000|00000000|11111111|11111111|11111111|11110011|00011|
	//                                                                                                                   |valid|
	//                                                                                                                   |bits |
	//                                                                                                                   |pre- |
	//                                                                                                                   |sent |
	//                                                                                                                   |in x |
	//                                                                                                                   |(5)  |
	c = byte('e')
	n += uint(huffmanCodeLen[c]) // n += 5, n = 10
	x <<= huffmanCodeLen[c] % 64 // x <<= 5 =         |000000|00000000|00000000|11111111|11111111|11111111|11110011|00011000|00|
	//                                                                                                             |valid bits |
	//                                                                                                             |  present  |
	//                                                                                                             | in x (10) |
	x |= uint64(huffmanCodes[c]) // x |= 0x5 =        |000000|00000000|00000000|11111111|11111111|11111111|11110011|00011001|01|
	if n >= 32 {                 // false
	}

	// ===========================================================================================================================
	// ------------------------+
	// 'l'                     |
	// ------------------------+
	n = 10
	x = 0x3ffffffcc65 //                              |000000|00000000|00000000|11111111|11111111|11111111|11110011|00011001|01|
	//                                                                                                             |valid bits |
	//                                                                                                             |  present  |
	//                                                                                                             | in x (10) |
	c = byte('l')
	n += uint(huffmanCodeLen[c]) // n += 6, n = 16
	x <<= huffmanCodeLen[c] % 64 // x <<= 6 =          |00000000|00000000|11111111|11111111|11111111|11110011|00011001|01000000|
	//                                                                                                       |   valid bits    |
	//                                                                                                       |present in x (16)|
	x |= uint64(huffmanCodes[c]) // x |= 0x28          |00000000|00000000|11111111|11111111|11111111|11110011|00011001|01101000|
	if n >= 32 {                 // false
	}

	// ===========================================================================================================================
	// ------------------------+
	// 'l'                     |
	// ------------------------+
	n = 16
	x = 0xfffffff31968 //                              |00000000|00000000|11111111|11111111|11111111|11110011|00011001|01101000|
	//                                                                                                       |   valid bits    |
	//                                                                                                       |present in x (16)|
	c = byte('l')
	n += uint(huffmanCodeLen[c]) // n += 6, n = 22
	x <<= huffmanCodeLen[c] % 64 // x <<= 6 =          |00|00000000|11111111|11111111|11111111|11110011|00011001|01101000|000000|
	//                                                                                                 |   valid bits present   |
	//                                                                                                 |      in x (22)         |
	x |= uint64(huffmanCodes[c]) // x |= 0x28          |00|00000000|11111111|11111111|11111111|11110011|00011001|01101000|101000|
	if n >= 32 {                 // false
	}

	// ===========================================================================================================================
	// ------------------------+
	// 'o'                     |
	// ------------------------+
	n = 22
	x = 0x3ffffffcc65a28 //                            |00|00000000|11111111|11111111|11111111|11110011|00011001|01101000|101000|
	//                                                                                                 |   valid bits present   |
	//                                                                                                 |      in x (22)         |
	c = byte('o')
	n += uint(huffmanCodeLen[c]) // n += 5, n = 27
	x <<= huffmanCodeLen[c] % 64 // x <<= 5 =          |00000|11111111|11111111|11111111|11110011|00011001|01101000|10100000|000|
	//                                                                                           | valid bits present in x (27) |
	x |= uint64(huffmanCodes[c]) // x |= 0x7           |00000|11111111|11111111|11111111|11110011|00011001|01101000|10100000|111|
	if n >= 32 {                 // false
	}

	// ===========================================================================================================================
	// ------------------------+
	// ' ' (space)             |
	// ------------------------+
	n = 27
	x = 0x7ffffff98cb4507 //                           |00000|11111111|11111111|11111111|11110011|00011001|01101000|10100000|111|
	//                                                                                           | valid bits present in x (27) |
	c = byte(' ')
	n += uint(huffmanCodeLen[c]) // n += 6, n = 33
	x <<= huffmanCodeLen[c] % 64 // x <<= 6 =          |1111111|11111111|11111111|11110011|00011001|01101000|10100000|11100000|0|
	//                                                                                    |    valid bits present in x (33)     |
	x |= uint64(huffmanCodes[c]) // x |= 0x14          |1111111|11111111|11111111|11110011|00011001|01101000|10100000|11101010|0|
	if n >= 32 {                 // true
		n %= 32             //      n = 1
		y := uint32(x >> n) //      uint32(x >> 1) = 4 byte batch                         |00011001|01101000|10100000|11101010|
		//                                                                                |          4 byte batch             |
		dst = append(dst, byte(y>>24), byte(y>>16), byte(y>>8), byte(y))
		//                          dst = |11111111|11111111|11111111|11110011|00011001|01101000|10100000|11101010|
	}

	// ===========================================================================================================================
	// ------------------------+
	// 'W'                     |
	// ------------------------+
	n = 1                  //      left over valid bits of huffman code
	x = 0xffffffe632d141d4 //                          |1111111|11111111|11111111|11110011|00011001|01101000|10100000|11101010|0|
	//                                                                                                                         ^
	//                                                                                                                         |
	//                                                                                                valid bits present in x (1)
	c = byte('W')
	n += uint(huffmanCodeLen[c]) // n += 7, n = 8
	x <<= huffmanCodeLen[c] % 64 // x <<= 7 =          |11111111|11111111|11110011|00011001|01101000|10100000|11101010|00000000|
	//                                                                                                                | valid  |
	//                                                                                                                | bits   |
	//                                                                                                                | present|
	//                                                                                                                | in x   |
	//                                                                                                                |   (8)  |
	x |= uint64(huffmanCodes[c]) // x |= 0x72 =        |11111111|11111111|11110011|00011001|01101000|10100000|11101010|01110010|
	if n >= 32 {                 // false
	}

	// ===========================================================================================================================
	// ------------------------+
	// 'o'                     |
	// ------------------------+
	n = 8
	x = 0xfffff31968a0ea72 //                          |11111111|11111111|11110011|00011001|01101000|10100000|11101010|01110010|
	//                                                                                                                | valid  |
	//                                                                                                                | bits   |
	//                                                                                                                | present|
	//                                                                                                                | in x   |
	//                                                                                                                |   (8)  |
	c = byte('o')
	n += uint(huffmanCodeLen[c]) // n += 5, n = 13
	x <<= huffmanCodeLen[c] % 64 // x <<= 5 =         |111|11111111|11110011|00011001|01101000|10100000|11101010|01110010|00000|
	//                                                                                                          |  valid bits  |
	//                                                                                                          | present in x |
	//                                                                                                          |     (13)     |
	x |= uint64(huffmanCodes[c]) // x |= 0x7          |111|11111111|11110011|00011001|01101000|10100000|11101010|01110010|00111|
	if n >= 32 {                 // false
	}

	// ===========================================================================================================================
	// ------------------------+
	// 'r'                     |
	// ------------------------+
	n = 13
	x = 0xfffe632d141d4e47 //                         |111|11111111|11110011|00011001|01101000|10100000|11101010|01110010|00111|
	//                                                                                                          |  valid bits  |
	//                                                                                                          | present in x |
	//                                                                                                          |     (13)     |
	c = byte('r')
	n += uint(huffmanCodeLen[c]) // n += 6, n = 19
	x <<= huffmanCodeLen[c] % 64 // x <<= 6 =         |11111|11110011|00011001|01101000|10100000|11101010|01110010|00111000|000|
	//                                                                                                   | valid bits present  |
	//                                                                                                   |       in x (19)     |
	x |= uint64(huffmanCodes[c]) // x |= 0x2c         |11111|11110011|00011001|01101000|10100000|11101010|01110010|00111101|100|
	if n >= 32 {                 // false
	}

	// ===========================================================================================================================
	// ------------------------+
	// 'l'                     |
	// ------------------------+
	n = 19
	x = 0xff98cb45075391ec //                         |11111|11110011|00011001|01101000|10100000|11101010|01110010|00111101|100|
	//                                                                                                   | valid bits present  |
	//                                                                                                   |       in x (19)     |
	c = byte('l')
	n += uint(huffmanCodeLen[c]) // n += 6, n = 25
	x <<= huffmanCodeLen[c] % 64 // x <<= 6 =         |1110011|00011001|01101000|10100000|11101010|01110010|00111101|10000000|0|
	//                                                                                            |valid bits present in x (25)|
	x |= uint64(huffmanCodes[c]) // x |= 0x28         |1110011|00011001|01101000|10100000|11101010|01110010|00111101|10010100|0|
	if n >= 32 {                 // false
	}

	// ===========================================================================================================================
	// ------------------------+
	// 'd'                     |
	// ------------------------+
	n = 25
	x = 0xe632d141d4e47b28 //                         |1110011|00011001|01101000|10100000|11101010|01110010|00111101|10010100|0|
	//                                                                                            |valid bits present in x (25)|
	c = byte('d')
	n += uint(huffmanCodeLen[c]) // n += 6, n = 31
	x <<= huffmanCodeLen[c] % 64 // x <<= 6 =         |1|00011001|01101000|10100000|11101010|01110010|00111101|10010100|0000000|
	//                                                                                      |   valid bits present in x (31)   |
	x |= uint64(huffmanCodes[c]) // x |= 0x24         |1|00011001|01101000|10100000|11101010|01110010|00111101|10010100|0100100|
	if n >= 32 {                 // false
	}

	// ===========================================================================================================================
	// ------------------------+
	// '!'                     |
	// ------------------------+
	n = 31
	x = 0x8cb45075391eca24 //                         |1|00011001|01101000|10100000|11101010|01110010|00111101|10010100|0100100|
	//                                                                                      |   valid bits present in x (31)   |
	c = byte('!')
	n += uint(huffmanCodeLen[c]) // n += 10, n = 41
	x <<= huffmanCodeLen[c] % 64 // x <<= 10 =        |1101000|10100000|11101010|01110010|00111101|10010100|01001000|00000000|0|
	//                                                                          |          valid bits present in x (41)        |
	x |= uint64(huffmanCodes[c]) // x |= 0x3f8        |1101000|10100000|11101010|01110010|00111101|10010100|01001001|11111100|0|
	if n >= 32 {                 // true
		n %= 32             //      n = 9
		y := uint32(x >> n) //      uint32(x >> 1) = 4 byte batch               |01110010|00111101|10010100|01001001|
		//                                                                      |          4 byte batch             |
		dst = append(dst, byte(y>>24), byte(y>>16), byte(y>>8), byte(y))
		//                          dst = |11111111|11111111|11111111|11110011|00011001|01101000|10100000|11101010|01110010|00111101|10010100|01001001|
	}

	// ===========================================================================================================================
	// ------------------------+
	// 0x88                    |
	// ------------------------+
	n = 9
	x = 0xd141d4e47b2893f8 //                         |1101000|10100000|11101010|01110010|00111101|10010100|01001001|11111100|0|
	//                                                                                                              |valid bits|
	//                                                                                                              |present in|
	//                                                                                                              |   x (9)  |
	c = byte(0x88)
	n += uint(huffmanCodeLen[c]) // n += 22, n = 31
	x <<= huffmanCodeLen[c] % 64 // x <<= 22 =        |10|01110010|00111101|10010100|01001001|11111100|00000000|00000000|0000000|
	//                                                                                       |   valid bits present in x (31)   |
	x |= uint64(huffmanCodes[c]) // x |= 0x3fffd6     |10|01110010|00111101|10010100|01001001|11111100|01111111|11111111|1010110|
	if n >= 32 {                 // false
	}

	// no more bytes to encode
	// Add padding bits if necessary
	if over := n % 8; over > 0 { // over = 7
		const (
			eosCode    = 0x3fffffff                // |11111111|11111111|11111111|111111|
			eosNBits   = 30                        // eos code is 30 bits long
			eosPadByte = eosCode >> (eosNBits - 8) // get the left most byte of the eos code |1111111|
		)
		pad := 8 - over //                            pad = 1, how many bits to pad to get a full octet
		// (x << pad) - give room for padding
		// (eosPadByte >> over) - get the padding bits in place
		x = (x << pad) | (eosPadByte >> over)
		//  (x << pad)                                |0|01110010|00111101|10010100|01001001|11111100|01111111|11111111|1010110|0|
		//                                                                                  |   valid bits present in x (31)   | |
		//                                                                                                                      ^
		//                                                                                                                      |
		//                                                                                                              room for padding (1 bit)
		//  (eosPadByte >> over) =                    |0000000000000000000000000000000000000000000000000000000000000000000000001|
		//
		//                                                                                  |           4 byte batch             |
		//  (x << pad) | (eosPadByte >> over) =       |0|01110010|00111101|10010100|01001001|11111100|01111111|11111111|1010110|1|
		//                                                                                  |   valid bits present in x (31)   | |
		//                                                                                                                      ^
		//                                                                                                                      |
		//                                                                                                              room for padding (1 bit)
		n += pad // = 32
	}

	// n in (0, 8, 16, 24, 32), write last batch of huffman codes to destination
	switch n / 8 {
	case 0: // all batches were already written to destination
		return dst
	case 1: // last batch has only one byte of data possibly padded out
		return append(dst, byte(x))
	case 2: // last batch has only two bytes of data possibly padded out
		y := uint16(x)
		return append(dst, byte(y>>8), byte(y))
	case 3: // last batch has only 3 bytes of data possibly padded out
		y := uint16(x >> 8)
		return append(dst, byte(y>>8), byte(y), byte(x))
	}
	// case 4: // last batch is a full 32 bit batch, possibly padded out to 32 bits
	y := uint32(x)
	return append(dst, byte(y>>24), byte(y>>16), byte(y>>8), byte(y)) // OUR CASE
	// dst (final, 16 bytes in total) = |11111111|11111111|11111111|11110011|00011001|01101000|10100000|11101010|01110010|00111101|10010100|01001001|11111100|01111111|11111111|10101101|
}
