// https://datatracker.ietf.org/doc/html/rfc7230#section-5.4 => https://www.rfc-editor.org/rfc/rfc3986 => https://www.rfc-editor.org/rfc/rfc1630

// RFC1630
//
//
//
// THE PERCENT SIGN
// The percent sign ("%", ASCII 25 hex) is used as the escape
// character in the encoding scheme and is never allowed for anything
// else.
//
//
// HIERARCHICAL FORMS
// The slash ("/", ASCII 2F hex) character is reserved for the
// delimiting of substrings whose relationship is hierarchical.  This
// enables partial forms of the URI.  Substrings consisting of single
// or double dots ("." or "..") are similarly reserved.
//
//
// The significance of the slash between two segments is that the
// segment of the path to the left is more significant than the
// segment of the path to the right.  ("Significance" in this case
// refers solely to closeness to the root of the hierarchical
// structure and makes no value judgement!)
//
//
// HASH FOR FRAGMENT IDENTIFIERS
// The hash ("#", ASCII 23 hex) character is reserved as a delimiter
// to separate the URI of an object from a fragment identifier.
//
//
// QUERY STRINGS
// The question mark ("?", ASCII 3F hex) is used to delimit the
// boundary between the URI of a queryable object, and a set of words
// used to express a query on that object.  When this form is used,
// the combined URI stands for the object which results from the
// query being applied to the original object.

// Within the query string, the plus sign is reserved as shorthand
// notation for a space.  Therefore, real plus signs must be encoded.
// This method was used to make query URIs easier to pass in systems
// which did not allow spaces.

// The query string represents some operation applied to the object,
// but this specification gives no common syntax or semantics for it.
// In practice the syntax and sematics may depend on the scheme and
// may even on the base URI.
//
//
// OTHER RESERVED CHARACTERS
// The astersik ("*", ASCII 2A hex) and exclamation mark ("!" , ASCII
// 21 hex) are reserved for use as having special signifiance within
// specific schemes.
//
//
// Unsafe characters
// In canonical form, certain characters such as spaces, control
// characters, some characters whose ASCII code is used differently in
// different national character variant 7 bit sets, and all 8bit
// characters beyond DEL (7F hex, 128 decimal, beyond ASCII 7 bit characters)
// of the ISO Latin-1 set, shall not be used unencoded. This is a recommendation
// for trouble-free interchange, and as indicated below, the encoded set may be
// extended or reduced.
//
//
// CONVENTIONAL URI ENCODING SCHEME
// Where the local naming scheme uses ASCII characters which are not
// allowed in the URI, these may be represented in the URL by a
// percent sign "%" immediately followed by two hexadecimal digits
// (0-9, A-F) giving the ISO Latin 1 code for that character.
// Character codes other than those allowed by the syntax shall not
// be used unencoded in a URI.
//
//
// REDUCED OR INCREASED SAFE CHARACTER SETS
// The same encoding method may be used for encoding characters whose
// use, although technically allowed in a URI, would be unwise due to
// problems of corruption by imperfect gateways or misrepresentation
// due to the use of variant character sets, or which would simply be
// awkward in a given environment.  Because a % sign always indicates
// an encoded character, a URI may be made "safer" simply by encoding
// any characters considered unsafe, while leaving already encoded
// characters still encoded.  Similarly, in cases where a larger set
// of characters is acceptable, % signs can be selectively and
// reversibly expanded.
//
// Before two URIs can be compared, it is therefore necessary to
// bring them to the same encoding level.
//
// However, the reserved characters mentioned above have a quite
// different significance when encoded, and so may NEVER be encoded
// and unencoded in this way.
//
// The percent sign intended as such must always be encoded, as its
// presence otherwise always indicates an encoding.  Sequences which
// start with a percent sign but are not followed by two hexadecimal
// characters are reserved for future extension.
//
//
// Example 1
// The URIs
//
// http://info.cern.ch/albert/bertram/marie-claude
//
// and
//
// http://info.cern.ch/albert/bertram/marie%2Dclaude
//
// are identical, as the %2D encodes a hyphen character.
//
//
// Example 2
//
// The URIs
//
// http://info.cern.ch/albert/bertram/marie-claude
//
// and
//
// http://info.cern.ch/albert/bertram%2Fmarie-claude
//
// are NOT identical, as in the second case the encoded slash does not
// have hierarchical significance.
//
//
// Example 3
//
// The URIs
//
// fxqn:/us/va/reston/cnri/ietf/24/asdf%*.fred
//
// and
//
// news:12345667123%asdghfh@info.cern.ch
//
// are illegal, as all % characters imply encodings, and there is no
// decoding defined for "%*"  or "%as" in this recommendation.
//
//
// A reference to a particular part of a document may, including the fragment identifier, look like
//
// http://www.myu.edu/org/admin/people#andy
//
// in which case the string "#andy" is not sent to the server, but is
// retained by the client and used when the whole object had been
// retrieved.

// RFC1736
//
//
// A resource locator describes a location but never guarantees that
// access may be established.  While access is often desired when
// clients follow location instructions given in a conformant resource
// locator, the resource need not exist any longer or need not exist
// yet.

// RFC3986
//
//
//
// Overview of URIs
// ----------------------
// Uniform:
// Uniformity provides several benefits.  It allows different types
// of resource identifiers to be used in the same context, even when
// the mechanisms used to access those resources may differ.  It
// allows uniform semantic interpretation of common syntactic
// conventions across different types of resource identifiers.  It
// allows introduction of new types of resource identifiers without
// interfering with the way that existing identifiers are used.  It
// allows the identifiers to be reused in many different contexts,
// thus permitting new applications or protocols to leverage a pre-
// existing, large, and widely used set of resource identifiers.
//
// Resource
// This specification does not limit the scope of what might be a
// resource; rather, the term "resource" is used in a general sense
// for whatever might be identified by a URI.  Familiar examples
// include an electronic document, an image, a source of information
// with a consistent purpose (e.g., "today's weather report for Los
// Angeles"), a service (e.g., an HTTP-to-SMS gateway), and a
// collection of other resources.  A resource is not necessarily
// accessible via the Internet; e.g., human beings, corporations, and
// bound books in a library can also be resources.  Likewise,
// abstract concepts can be resources, such as the operators and
// operands of a mathematical equation, the types of a relationship
// (e.g., "parent" or "employee"), or numeric values (e.g., zero,
// one, and infinity).
//
// Identifier
// An identifier embodies the information required to distinguish
// what is being identified from all other things within its scope of
// identification.  Our use of the terms "identify" and "identifying"
// refer to this purpose of distinguishing one resource from all
// other resources, regardless of how that purpose is accomplished
// (e.g., by name, address, or context).  These terms should not be
// mistaken as an assumption that an identifier defines or embodies
// the identity of what is referenced, though that may be the case
// for some identifiers.  Nor should it be assumed that a system
// using URIs will access the resource identified: in many cases,
// URIs are used to denote resources without any intention that they
// be accessed.  Likewise, the "one" resource identified might not be
// singular in nature (e.g., a resource might be a named set or a
// mapping that varies over time).
//
//  URIs have a global scope and are interpreted consistently regardless
// of context, though the result of that interpretation may be in
// relation to the end-user's context.
//
//
// Generic Syntax
// --------------------
// Each URI begins with a scheme name that refers to a specification for
// assigning identifiers within that scheme. As such, the URI syntax is
// a federated and extensible naming system wherein each scheme's specification
// may further restrict the syntax and semantics of identifiers using that scheme.
//
// This specification defines those elements of the URI syntax that are
// required of all URI schemes or are common to many URI schemes.  It
// thus defines the syntax and semantics needed to implement a scheme-
// independent parsing mechanism for URI references, by which the
// scheme-dependent handling of a URI can be postponed until the
// scheme-dependent semantics are needed.
//
//
// URI, URL, and URN
// ----------------------
// A URI can be further classified as a locator, a name, or both.  The
// term "Uniform Resource Locator" (URL) refers to the subset of URIs
// that, in addition to identifying a resource, provide a means of
// locating the resource by describing its primary access mechanism
// (e.g., its network "location"). The term "Uniform Resource Name"
// (URN) has been used historically to refer to both URIs under the
// "urn" scheme [RFC2141], which are required to remain globally unique
// and persistent even when the resource ceases to exist or becomes
// unavailable, and to any other URI with the properties of a name.
//
//  An individual scheme does not have to be classified as being just one
// of "name" or "locator".  Instances of URIs from any given scheme may
// have the characteristics of names or locators or both, often
// depending on the persistence and care in the assignment of
// identifiers by the naming authority, rather than on any quality of
// the scheme.  Future specifications and related documentation should
// use the general term "URI" rather than the more restrictive terms
// "URL" and "URN" [RFC3305].
//
//
// Separating Identification from Interaction
// -----------------------------------------------
// A common misunderstanding of URIs is that they are only used to refer
// to accessible resources.  The URI itself only provides
// identification; access to the resource is neither guaranteed nor
// implied by the presence of a URI.  Instead, any operation associated
// with a URI reference is defined by the protocol element, data format
// attribute, or natural language text in which it appears.
//
// URI "resolution" is the process of determining an access mechanism and
// the appropriate parameters necessary to dereference a URI; this resolution
// may require several iterations.  To use that access mechanism to perform an
// action on the URI's resource is to "dereference" the URI.
//
// When URIs are used within information retrieval systems to identify
// sources of information, the most common form of URI dereference is
// "retrieval": making use of a URI in order to retrieve a representation
// of its associated resource. A "representation" is a sequence of octets,
// along with representation metadata describing those octets, that constitutes
// a record of the state of the resource at the time when the representation is
// generated. Retrieval is achieved by a process that might include using the URI
// as a cache key to check for a locally cached representation, resolution of the
// URI to determine an appropriate access mechanism (if any), and dereference of
// the URI for the sake of applying a retrieval operation.  Depending on the protocols
// used to perform the retrieval, additional information might be supplied about the
// resource (resource metadata) and its relation to other resources.
//
// Although many URI schemes are named after protocols, this does not imply that use of
// these URIs will result in access to the resource via the named protocol. URIs are
// often used simply for the sake of identification.  Even when a URI is used to retrieve
// a representation of a resource, that access might be through gateways, proxies, caches,
// and name resolution services that are independent of the protocol associated with the
// scheme name. he resolution of some URIs may require the use of more than one protocol
// (e.g., both DNS and HTTP are typically used to access an "http" URI's origin server
// when a representation isn't found in a local cache).
//
//
// Hierarchical Identifiers
// -----------------------------------------------
// The URI syntax is organized hierarchically, with components listed in order of decreasing
// significance from left to right. For some URI schemes, the visible hierarchy is limited to
// the scheme itself: everything after the scheme component delimiter (":") is considered
// opaque to URI processing.  Other URI schemes make the hierarchy explicit and visible to generic
// parsing algorithms.
//
// The generic syntax uses the slash ("/"), question mark ("?"), and number sign ("#") characters
// to delimit components that are significant to the generic parser's hierarchical interpretation
// of an identifier. In addition to aiding the readability of such identifiers through the consistent
// use of familiar syntax, this uniform representation of hierarchy across naming schemes allows
// scheme-independent references to be made relative to that hierarchy.
//
// It is often the case that a group or "tree" of documents has been constructed to serve a common
// purpose, wherein the vast majority of URI references in these documents point to resources within
// the tree rather than outside it. Similarly, documents located at a particular site are much more
// likely to refer to other resources at that site than to resources at remote sites. Relative referencing
// of URIs allows document trees to be partially independent of their location and access scheme.
// For instance, it is possible for a single set of hypertext documents to be simultaneously accessible
// and traversable via each of the "file", "http", and "ftp" schemes if the documents refer to each other
// with relative references. Furthermore, such document trees can be moved, as a whole, without changing
// any of the relative references.
//
// NOTE: Previous specifications used the terms "partial URI" and "relative URI" to denote a relative reference
// to a URI.  As some readers misunderstood those terms to mean that relative URIs are a subset of URIs rather
// than a method of referencing URIs, this specification simply refers to them as relative references.
//
//
// Characters
// -----------------------------------------------
// The URI syntax provides a method of encoding data, presumably for the sake of identifying a resource, as a
// sequence of characters. The URI characters are, in turn, frequently encoded as octets for transport or presentation.
// This specification does not mandate any particular character encoding for mapping between URI characters and the octets
// used to store or transmit those characters.  When a URI appears in a protocol element, the character encoding is defined
// by that protocol; without such a definition, a URI is assumed to be in the same character encoding as the surrounding text.
//
//
// Percent-Encoding
// -----------------------------------------------
// A percent-encoding mechanism is used to represent a data octet in a component when that octet's corresponding character is
// outside the allowed set or is being used as a delimiter of, or within, the component. A percent-encoded octet is encoded as
// a character triplet, consisting of the percent character "%" followed by the two hexadecimal digits representing that octet's
// numeric value. For example, "%20" is the percent-encoding for the binary octet "00100000" (ABNF: %x20), which in US-ASCII
// corresponds to the space character (SP).
//
//     pct-encoded = "%" HEXDIG HEXDIG
//
// The uppercase hexadecimal digits 'A' through 'F' are equivalent to the lowercase digits 'a' through 'f', respectively.
// If two URIs differ only in the case of hexadecimal digits used in percent-encoded octets, they are equivalent. For consistency,
// URI producers and normalizers should use uppercase hexadecimal digits for all percent-encodings.
//
//
// Reserved Characters
// -----------------------------------------------
// URIs include components and subcomponents that are delimited by characters in the "reserved" set. These characters are called
// "reserved" because they may (or may not) be defined as delimiters by the generic syntax, by each scheme-specific syntax, or by
// the implementation-specific syntax of a URI's dereferencing algorithm. If data for a URI component would conflict with a reserved
// character's purpose as a delimiter, then the conflicting data must be percent-encoded before the URI is formed.
//
//    reserved    = gen-delims / sub-delims
//
//    gen-delims  = ":" / "/" / "?" / "#" / "[" / "]" / "@"
//
//    sub-delims  = "!" / "$" / "&" / "'" / "(" / ")" / "*" / "+" / "," / ";" / "="
//
// The purpose of reserved characters is to provide a set of delimiting characters that are distinguishable from other data within a URI.
// URIs that differ in the replacement of a reserved character with its corresponding percent-encoded octet are not equivalent.
// Percent-encoding a reserved character, or decoding a percent-encoded octet that corresponds to a reserved character, will change how
// the URI is interpreted by most applications. Thus, characters in the reserved set are protected from normalization and are therefore safe
// to be used by scheme-specific and producer-specific algorithms for delimiting data subcomponents within a URI.
//
// A subset of the reserved characters (gen-delims) is used as delimiters of the generic URI components. A component's ABNF syntax rule will
// not use the reserved or gen-delims rule names directly; instead, each syntax rule lists the characters allowed within that component (i.e.,
// not delimiting it), and any of those characters that are also in the reserved set are "reserved" for use as subcomponent delimiters within
// the component. Only the most common subcomponents are defined by this specification; other subcomponents may be defined by a URI scheme's
// specification, or by the implementation-specific syntax of a URI's dereferencing algorithm, provided that such subcomponents are delimited by
// characters in the reserved set allowed within that component.
//
// URI producing applications should percent-encode data octets that correspond to characters in the reserved set unless these characters are
// specifically allowed by the URI scheme to represent data in that component.  If a reserved character is found in a URI component and no delimiting
// role is known for that character, then it must be interpreted as representing the data octet corresponding to that character's encoding in US-ASCII.
//
//
// Unreserved Characters
// -----------------------------------------------
// Characters that are allowed in a URI but do not have a reserved purpose are called unreserved. These include uppercase and lowercase letters, decimal digits,
// hyphen, period, underscore, and tilde.
//
//     unreserved  = ALPHA / DIGIT / "-" / "." / "_" / "~"
//
// URIs that differ in the replacement of an unreserved character with its corresponding percent-encoded US-ASCII octet are equivalent:they identify the same
// resource. However, URI comparison implementations do not always perform normalization prior to comparison. For consistency, percent-encoded octets in the
// ranges of ALPHA (%41-%5A and %61-%7A), DIGIT (%30-%39), hyphen (%2D), period (%2E), underscore (%5F), or tilde (%7E) should not be created by URI producers
// and, when found in a URI, should be decoded to their corresponding unreserved characters by URI normalizers.
//
//
// When to Encode or Decode
// -----------------------------------------------
// Under normal circumstances, the only time when octets within a URI are percent-encoded is during the process of producing the URI from its component parts.
// This is when an implementation determines which of the reserved characters are to be used as subcomponent delimiters and which can be safely used as data.
// Once produced, a URI is always in its percent-encoded form. When a URI is dereferenced, the components and subcomponents significant to the scheme-specific
// dereferencing process (if any) must be parsed and separated before the percent-encoded octets within those components can be safely decoded, as otherwise
// the data may be mistaken for component delimiters. The only exception is for percent-encoded octets corresponding to characters in the unreserved set, which
// can be decoded at any time. For example, the octet corresponding to the tilde ("~") character is often encoded as "%7E" by older URI processing implementations;
// the "%7E" can be replaced by "~" without changing its interpretation.
//
// Because the percent ("%") character serves as the indicator for percent-encoded octets, it must be percent-encoded as "%25" for that octet to be used as data
// within a URI. Implementations must not percent-encode or decode the same string more than once, as decoding an already decoded string might lead to misinterpre-
// ting a percent data octet as the beginning of a percent-encoding, or vice versa in the case of percent-encoding an already percent-encoded string.
//
//
// Syntax Components
// -----------------------------------------------
// The generic URI syntax consists of a hierarchical sequence of components referred to as the scheme, authority, path, query, and fragment.
//     URI         = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
//
//     hier-part   = "//" authority path-abempty
//                 / path-absolute
//                 / path-rootless
//                 / path-empty
//
// The scheme and path components are required, though the path may be empty (no characters). When authority is present, the path must either be empty or begin
// with a slash ("/") character. When authority is not present, the path cannot begin with two slash characters ("//"). These restrictions result in five different
// ABNF rules for a path, only one of which will match any given URI reference.
//
// The following are two example URIs and their component parts:
//     foo://example.com:8042/over/there?name=ferret#nose
//     \_/   \______________/\_________/ \_________/ \__/
//      |           |            |            |        |
//  scheme     authority       path        query   fragment
//      |   _____________________|__
//     / \ /                        \
//     urn:example:animal:ferret:nose
//
//
// Scheme
// -----------------------------------------------
// Each URI begins with a scheme name that refers to a specification for assigning identifiers within that scheme. As such, the URI syntax is a federated and
// extensible naming system wherein each scheme's specification may further restrict the syntax and semantics of identifiers using that scheme.
//
// Scheme names consist of a sequence of characters beginning with a letter and followed by any combination of letters, digits, plus ("+"), period ("."), or
// hyphen ("-"). Although schemes are case-insensitive, the canonical form is lowercase and documents that specify schemes must do so with lowercase letters.
// An implementation should accept uppercase letters as equivalent to lowercase in scheme names (e.g., allow "HTTP" as well as "http") for the sake of robustness
// but should only produce lowercase scheme names for consistency.
//
//     scheme      = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )
//
// When presented with a URI that violates one or more scheme-specific restrictions, the scheme-specific resolution process should flag the reference as an error
// rather than ignore the unused parts; doing so reduces the number of equivalent URIs and helps detect abuses of the generic syntax, which might indicate that
// the URI has been constructed to mislead the user.
//
//
// Authority
// -----------------------------------------------
// Many URI schemes include a hierarchical element for a naming authority so that governance of the name space defined by the remainder of the URI is delegated to
// that authority (which may, in turn, delegate it further). The generic syntax provides a common means for distinguishing an authority based on a registered
// name or server address, along with optional port and user information.
//
// The authority component is preceded by a double slash ("//") and is bterminated by the next slash ("/"), question mark ("?"), or number sign ("#") character,
// or by the end of the URI.
//
//     authority   = [ userinfo "@" ] host [ ":" port ]
//
// URI producers and normalizers should omit the ":" delimiter that separates host from port if the port component is empty. Some schemes do not allow the userinfo
// and/or port subcomponents.
//
// If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character. Non-validating parsers (those
// that merely separate a URI reference into its major components) will often ignore the subcomponent structure of authority, treating it as an opaque string
// from the double-slash to the first terminating delimiter, until such time as the URI is dereferenced.
//
//
// User Information
// -----------------------------------------------
// The userinfo subcomponent may consist of a user name and, optionally, scheme-specific information about how to gain authorization to access the resource.
// The user information, if present, is followed by a commercial at-sign ("@") that delimits it from the host.
//
//     userinfo    = *( unreserved / pct-encoded / sub-delims / ":" )
//
// Use of the format "user:password" in the userinfo field is deprecated. Applications should not render as clear text any data after the first colon (":")
// character found within a userinfo subcomponent unless the data after the colon is the empty string (indicating no password). Applications may choose to ignore
// or reject such data when it is received as part of a reference and should reject the storage of such data in unencrypted form. The passing of authentication
// information in clear text has proven to be a security risk in almost every case where it has been used.
//
//
// Host
// -----------------------------------------------
// The host subcomponent of authority is identified by an IP literal encapsulated within square brackets, an IPv4 address in dotted-decimal form, or a registered
// name. The host subcomponent is case-insensitive. The presence of a host subcomponent within a URI does not imply that the scheme requires access to the given
// host on the Internet. In some cases, the data within the host component identifies a registered name that has nothing to do with an Internet host. We use the
// name "host" for the ABNF rule because that is its most common purpose, not its only purpose.
//
//     host        = IP-literal / IPv4address / reg-name
//
// The syntax rule for host is ambiguous because it does not completely distinguish between an IPv4address and a reg-name. In order to disambiguate the syntax, we
// apply the "first-match-wins" algorithm: If host matches the rule for IPv4address, then it should be considered an IPv4 address literal and not a reg-name.
// Although host is case-insensitive, producers and normalizers should use lowercase for registered names and hexadecimal addresses for the sake of uniformity,
// while only using uppercase letters for percent-encodings.
//
// A host identified by an Internet Protocol literal address, version 6 or later, is distinguished by enclosing the IP literal within square brackets ("[" and "]").
// This is the only place where square bracket characters are allowed in the URI syntax. In anticipation of future, as-yet-undefined IP literal address formats,
// an implementation may use an optional version flag to indicate such a format explicitly rather than rely on heuristic determination.
//
//     IP-literal = "[" ( IPv6address / IPvFuture  ) "]"
//
//     IPvFuture  = "v" 1*HEXDIG "." 1*( unreserved / sub-delims / ":" )
//
// The version flag does not indicate the IP version; rather, it indicates future versions of the literal format. As such, implementations must not provide the
// version flag for the existing IPv4 and IPv6 literal address forms described below. If a URI containing an IP-literal that starts with "v" (case-insensitive),
// indicating that the version flag is present, is dereferenced by an application that does not know the meaning of that version flag, then the application should
// return an appropriate error for "address mechanism not supported".
//
// A host identified by an IPv6 literal address is represented inside the square brackets without a preceding version flag. This syntax does not support IPv6
// scoped addressing zone identifiers.
//
// A 128-bit IPv6 address is divided into eight 16-bit pieces (each peace reprsents 16 bits of address in hexadecimal). Each piece is represented numerically in
// case-insensitive hexadecimal, using one to four hexadecimal digits (leading zeroes are permitted). The eight encoded pieces are given most-significant first,
// separated by colon characters. Optionally, the least-significant two pieces may instead be represented in IPv4 address textual format (IPv4-mapped IPv6 addresses).
// A sequence of one or more consecutive zero-valued 16-bit pieces within the address may be elided, omitting all their digits and leaving exactly two consecutive
// colons in their place to mark the elision.
//
//     IPv6address =                            6( h16 ":" ) ls32
//                 /                       "::" 5( h16 ":" ) ls32
//                 / [               h16 ] "::" 4( h16 ":" ) ls32
//                 / [ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
//                 / [ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
//                 / [ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
//                 / [ *4( h16 ":" ) h16 ] "::"              ls32
//                 / [ *5( h16 ":" ) h16 ] "::"              h16
//                 / [ *6( h16 ":" ) h16 ] "::"
//
//     ls32        = ( h16 ":" h16 ) / IPv4address
//                 ; least-significant 32 bits of address
//
//     h16         = 1*4HEXDIG
//                 ; 16 bits of address represented in hexadecimal
//
// A host identified by an IPv4 literal address is represented in dotted-decimal notation (a sequence of four decimal numbers in the range 0 to 255, separated by ".").
//
//     IPv4address = dec-octet "." dec-octet "." dec-octet "." dec-octet
//
//     dec-octet   = DIGIT                 ; 0-9
//                 / %x31-39 DIGIT         ; 10-99   (%x31-39 means digits from 1 to 9 prepended to a DIGIT, which is from 0 to 9)
//                 / "1" 2DIGIT            ; 100-199 (means the digit 1 prepended to 2 DIGITs, which are in the range of 0 to 9)
//                 / "2" %x30-34 DIGIT     ; 200-249 (means the digit 2 prepended to digits from 0 to 4, which are prepended to a DIGIT, which is from 0 to 9)
//                 / "25" %x30-35          ; 250-255 (means digits 2 and 5 prepended to a digit from 0 to 5)
//
// A host identified by a registered name is a sequence of characters usually intended for lookup within a locally defined host or service name registry, though
// the URI's scheme-specific semantics may require that a specific registry (or fixed name table) be used instead. The most common name registry mechanism is the
// Domain Name System (DNS). A registered name intended for lookup in the DNS uses the syntax:
//     <domain> ::= <subdomain> | " "
//
//     <subdomain> ::= <label> | <subdomain> "." <label>
//
//     <label> ::= <letter> [ [ <ldh-str> ] <let-dig> ]
//              must start with a letter, end with a letter or digit, and have
//              as interior characters only letters, digits, and hyphen ;
//
//     <ldh-str> ::= <let-dig-hyp> | <let-dig-hyp> <ldh-str>
//
//     <let-dig-hyp> ::= <let-dig> | "-"
//
//     <let-dig> ::= <letter> | <digit>
//
//     <letter> ::= any one of the 52 alphabetic characters A through Z in upper case and a through z in lower case
//
//     <digit> ::= any one of the ten digits 0 through 9
//
// Note that while upper and lower case letters are allowed in domain names, no significance is attached to the case. That is, two names with the same spelling but
// different case are to be treated as if identical.
//
// The labels must follow the rules for ARPANET host names. They must start with a letter, end with a letter or digit, and have as interior characters only letters,
// digits, and hyphen. There are also some restrictions on the length. Labels must be 63 characters or less.
//
// For example, the following strings identify hosts in the Internet: A.ISI.EDU  XX.LCS.MIT.EDU  SRI-NIC.ARPA .
//
// Such a name consists of a sequence of domain labels separated by ".", each domain label starting and ending with an alphanumeric character and possibly also
// containing "-" characters. The rightmost domain label of a fully qualified domain name in DNS may be followed by a single "." and should be if it is necessary
// to distinguish between the complete domain name and some local domain.
//
//     reg-name    = *( unreserved / pct-encoded / sub-delims )
//
// If the URI scheme defines a default for host, then that default applies when the host subcomponent is undefined or when the registered name is empty (zero length).
// For example, the "file" URI scheme is defined so that no authority, an empty host, and "localhost" all mean the end-user's machine, whereas the "http" scheme
// considers a missing authority or empty host invalid.
//
// A URI resolution implementation might use DNS, host tables, yellow pages, NetInfo, WINS, or any other system for lookup of registered names. However, a globally
// scoped naming system, such as DNS fully qualified domain names, is necessary for URIs intended to have global scope. URI producers should use names that conform
// to the DNS syntax, even when use of DNS is not immediately apparent, and should limit these names to no more than 255 characters in length.
//
// The reg-name syntax allows percent-encoded octets in order to represent non-ASCII registered names in a uniform way that is independent of the underlying name
// resolution technology. Non-ASCII characters must first be encoded according to UTF-8, and then each octet of the corresponding UTF-8 sequence must be
// percent-encoded to be represented as URI characters. URI producing applications must not use percent-encoding in host unless it is used to represent a UTF-8
// character sequence. URI producing applications must not use percent-encoding in host unless it is used to represent a UTF-8 character sequence. When a non-ASCII
// registered name represents an internationalized domain name intended for resolution via the DNS, the name must be transformed to the IDNA encoding [RFC3490] prior
// to name lookup. URI producers should provide these registered names in the IDNA encoding, rather than a percent-encoding, if they wish to maximize interoperability
// with legacy URI resolvers.
//
//
// IDNA
// -----------------------------------------------
// IDNA works by allowing applications to use certain ASCII name labels (beginning with a special prefix) to represent non-ASCII name labels. Lower-layer protocols
// need not be aware of this.
//
// This document does not require any applications to conform to IDNA, but applications can elect to use IDNA in order to support IDN (Internationalized Domain Names)
// while maintaining interoperability with existing infrastructure. If an application wants to use non-ASCII characters in domain names, IDNA is the only currently-
// defined option.
//
// Rather than rely on widespread updating of all components, IDNA depends on updates to user applications only; no changes are needed to the DNS protocol or any
// DNS servers or the resolvers on user's computers.
//
// The IDNA specification solves the problem of extending the repertoire of characters that can be used in domain names to include the Unicode repertoire (with some
// restrictions).
//
// The IDNA protocol is contained completely within applications. It is not a client-server or peer-to-peer protocol: everything is done inside the application itself.
// When used with a DNS resolver library, IDNA is inserted as a "shim" between the application and the resolver library. When used for writing names into a DNS zone,
// IDNA is used just before the name is committed to the zone.
//
// There are two operations:
//     - The ToASCII operation is used before sending an IDN to something that expects ASCII names (such as a resolver) or writing an IDN into a place that expects
//       ASCII names (such as a DNS master file).
//
//     - The ToUnicode operation is used when displaying names to users, for example names obtained from a DNS zone.
//
// It is important to note that the ToASCII operation can fail.  If it fails when processing a domain name, that domain name cannot be used as an internationalized
// domain name and the application has to have some method of dealing with this failure.
//
// IDNA conformance means adherence to the following four requirements:
//    1) Whenever dots are used as label separators, the following characters MUST be recognized as dots: U+002E (full stop), U+3002 (ideographic full stop),
//       U+FF0E (fullwidth full stop), U+FF61 (halfwidth ideographic full stop).
//
//    2) Whenever a domain name is put into an IDN-unaware domain name slot, it MUST contain only ASCII characters. Given an internationalized domain name (IDN),
//       an equivalent domain name satisfying this requirement can be obtained by applying the ToASCII operation to each label and, if dots are used as label
//       separators, changing all the label separators to U+002E (full stop).
//
//    3) ACE (ASCII Compatible Encoding) labels obtained from domain name slots SHOULD be hidden from users when it is known that the environment can handle the
//       non-ACE form, except when the ACE form is explicitly requested. When it is not known whether or not the environment can handle the non-ACE form, the
//       application MAY use the non-ACE form (which might fail, such as by not being displayed properly), or it MAY use the ACE form (which will look unintelligle
//       to the user). Given an internationalized domain name, an equivalent domain name containing no ACE labels can be obtained by applying the ToUnicode operation
//       to each label. When requirements 2 and 3 both apply, requirement 2 takes precedence.
//
//    4) Whenever two labels are compared, they MUST be considered to match if and only if they are equivalent, that is, their ASCII forms (obtained by applying
//       ToASCII) match using a case-insensitive ASCII comparison. Whenever two names are compared, they MUST be considered to match if and only if their
//       corresponding labels match, regardless of whether the names use the same forms of label separators.
//
// The input to ToASCII or ToUnicode is a single label that is a sequence of Unicode code points (remember that all ASCII code points are also Unicode code points).
// If a domain name is represented using a character set other than Unicode or US-ASCII, it will first need to be transcoded to Unicode.
//
// Starting from a whole domain name, the steps that an application takes to do the conversions are:
//     1) Split the domain name into individual labels. The labels do not include the separator.
//
//     2) For each label, decide whether or not to enforce the restrictions on ASCII characters in host names.
//
//     3) Process each label with either the ToASCII or the ToUnicode operation as appropriate. Typically, you use the ToASCII operation if you are about to put the
//        name into an IDN-unaware slot, and you use the ToUnicode operation if you are displaying the name to a user.
//
//     4) If ToASCII was applied in step 3 and dots are used as label separators, change all the label separators to U+002E (full stop).
//
// The ToASCII operation takes a sequence of Unicode code points that make up one label and transforms it into a sequence of code points in the ASCII range (0..7F).
// If ToASCII succeeds, the original sequence and the resulting sequence are equivalent labels.
//
// It is important to note that the ToASCII operation can fail. ToASCII fails if any step of it fails.  If any step of the ToASCII operation fails on any label in a
// domain name, that domain name MUST NOT be used as an internationalized domain name. The method for dealing with this failure is application-specific.
//
// The inputs to ToASCII are a sequence of code points, the AllowUnassigned flag, and the UseSTD3ASCIIRules flag. The output of ToASCII is either a sequence of ASCII
// code points or a failure condition.
//
// ToASCII never alters a sequence of code points that are all in the ASCII range to begin with (although it could fail).  Applying the ToASCII operation multiple
// times has exactly the same effect as applying it just once.
//
// ToASCII consists of the following steps:
//    1. If the sequence contains any code points outside the ASCII range (0..7F) then proceed to step 2, otherwise skip to step 3.
//
// https://www.rfc-editor.org/rfc/rfc3490#section-3.1 TODO!!!!!
//
//
// Port
// -----------------------------------------------
// The port subcomponent of authority is designated by an optional port
// number in decimal following the host and delimited from it by a
// single colon (":") character.
//
//    port        = *DIGIT
//
// A scheme may define a default port.  For example, the "http" scheme
// defines a default port of "80", corresponding to its reserved TCP
// port number.  The type of port designated by the port number (e.g.,
// TCP, UDP, SCTP) is defined by the URI scheme.  URI producers and
// normalizers should omit the port component and its ":" delimiter if
// port is empty or if its value would be the same as that of the
// scheme's default.
//
//
// Path
// -----------------------------------------------
// The path component contains data, usually organized in hierarchical
// form, that, along with data in the non-hierarchical query component,
// serves to identify a resource within the scope of the
// URI's scheme and naming authority (if any).  The path is terminated
// by the first question mark ("?") or number sign ("#") character, or
// by the end of the URI.
//
// If a URI contains an authority component, then the path component
// must either be empty or begin with a slash ("/") character.  If a URI
// does not contain an authority component, then the path cannot begin
// with two slash characters ("//").
//
// In addition, a URI reference may be a relative-path reference, in which case the
// first path segment cannot contain a colon (":") character.
//
// The ABNF requires five separate rules to disambiguate these cases, only one of
// which will match the path substring within a given URI reference.  We
// use the generic term "path component" to describe the URI substring
// matched by the parser to one of these rules.
//
//     path          = path-abempty    ; begins with "/" or is empty
//                   / path-absolute   ; begins with "/" but not "//"
//                   / path-noscheme   ; begins with a non-colon segment
//                   / path-rootless   ; begins with a segment
//                   / path-empty      ; zero characters
//
//     path-abempty  = *( "/" segment )
//     path-absolute = "/" [ segment-nz *( "/" segment ) ]
//     path-noscheme = segment-nz-nc *( "/" segment )
//     path-rootless = segment-nz *( "/" segment )
//     path-empty    = 0<pchar>
//
//     segment       = *pchar
//     segment-nz    = 1*pchar
//     segment-nz-nc = 1*( unreserved / pct-encoded / sub-delims / "@" )
//                   ; non-zero-length segment without any colon ":"
//
//     pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"
//
//     reserved      = gen-delims / sub-delims
//     gen-delims    = ":" / "/" / "?" / "#" / "[" / "]" / "@"
//     sub-delims    = "!" / "$" / "&" / "'" / "(" / ")" / "*" / "+" / "," / ";" / "="
//
// A path consists of a sequence of path segments separated by a slash
// ("/") character.  A path is always defined for a URI, though the
// defined path may be empty (zero length).  Use of the slash character
// to indicate hierarchy is only required when a URI will be used as the
// context for relative references.  For example, the URI
// <mailto:fred@example.com> has a path of "fred@example.com", whereas
// the URI <foo://info.example.com?fred> has an empty path.
//
// The path segments "." and "..", also known as dot-segments, are
// defined for relative reference within the path name hierarchy.  They
// are intended for use at the beginning of a relative-path reference
// to indicate relative position within the hierarchical
// tree of names.  This is similar to their role within some operating
// systems' file directory structures to indicate the current directory
// and parent directory, respectively.  However, unlike in a file
// system, these dot-segments are only interpreted within the URI path
// hierarchy and are removed as part of the resolution process.
//
// Aside from dot-segments in hierarchical paths, a path segment is
// considered opaque by the generic syntax.  URI producing applications
// often use the reserved characters allowed in a segment to delimit
// scheme-specific or dereference-handler-specific subcomponents.  For
// example, the semicolon (";") and equals ("=") reserved characters are
// often used to delimit parameters and parameter values applicable to
// that segment.  The comma (",") reserved character is often used for
// similar purposes.  For example, one URI producer might use a segment
// such as "name;v=1.1" to indicate a reference to version 1.1 of
// "name", whereas another might use a segment such as "name,1.1" to
// indicate the same.  Parameter types may be defined by scheme-specific
// semantics, but in most cases the syntax of a parameter is specific to
// the implementation of the URI's dereferencing algorithm.
//
//
// Query
// -----------------------------------------------
//  The query component contains non-hierarchical data that, along with
// data in the path component, serves to identify a
// resource within the scope of the URI's scheme and naming authority
// (if any).  The query component is indicated by the first question
// mark ("?") character and terminated by a number sign ("#") character
// or by the end of the URI.
//
//     query       = *( pchar / "/" / "?" )
//
// The characters slash ("/") and question mark ("?") may represent data
// within the query component.  Beware that some older, erroneous
// implementations may not handle such data correctly when it is used as
// the base URI for relative references, apparently
// because they fail to distinguish query data from path data when
// looking for hierarchical separators.  However, as query components
// are often used to carry identifying information in the form of
// "key=value" pairs and one frequently used value is a reference to
// another URI, it is sometimes better for usability to avoid percent-
// encoding those characters.
//
//
// Fragment
// -----------------------------------------------
// The fragment identifier component of a URI allows indirect
// identification of a secondary resource by reference to a primary
// resource and additional identifying information.  The identified
// secondary resource may be some portion or subset of the primary
// resource, some view on representations of the primary resource, or
// some other resource defined or described by those representations.  A
// fragment identifier component is indicated by the presence of a
// number sign ("#") character and terminated by the end of the URI.
//
//     fragment    = *( pchar / "/" / "?" )
//
// The semantics of a fragment identifier are defined by the set of
// representations that might result from a retrieval action on the
// primary resource. The fragment's format and resolution is therefore
// dependent on the media type [RFC2046] of a potentially retrieved
// representation, even though such a retrieval is only performed if the
// URI is dereferenced. If no such representation exists, then the
// semantics of the fragment are considered unknown and are effectively
// unconstrained.  Fragment identifier semantics are independent of the
// URI scheme and thus cannot be redefined by scheme specifications.
//
// Individual media types may define their own restrictions on or
// structures within the fragment identifier syntax for specifying
// different types of subsets, views, or external references that are
// identifiable as secondary resources by that media type.  If the
// primary resource has multiple representations, as is often the case
// for resources whose representation is selected based on attributes of
// the retrieval request (a.k.a., content negotiation), then whatever is
// identified by the fragment should be consistent across all of those
// representations.  Each representation should either define the
// fragment so that it corresponds to the same secondary resource,
// regardless of how it is represented, or should leave the fragment
// undefined (i.e., not found).
//
// As with any URI, use of a fragment identifier component does not
// imply that a retrieval action will take place.  A URI with a fragment
// identifier may be used to refer to the secondary resource without any
// implication that the primary resource is accessible or will ever be
// accessed.
//
// The characters slash ("/") and question mark ("?") are allowed to
// represent data within the fragment identifier.  Beware that some
// older, erroneous implementations may not handle this data correctly
// when it is used as the base URI for relative references.
//
//
// URI Reference
// -----------------------------------------------
// URI-reference is used to denote the most common usage of a resource
// identifier.
//
//     URI-reference = URI / relative-ref
//
//     relative-ref  = relative-part [ "?" query ] [ "#" fragment ]
//
//     relative-part = "//" authority path-abempty
//                   / path-absolute
//                   / path-noscheme
//                   / path-empty
//
//     path          = path-abempty    ; begins with "/" or is empty
//                   / path-absolute   ; begins with "/" but not "//"
//                   / path-noscheme   ; begins with a non-colon segment
//                   / path-rootless   ; begins with a segment
//                   / path-empty      ; zero characters
//
//     path-abempty  = *( "/" segment )
//     path-absolute = "/" [ segment-nz *( "/" segment ) ]
//     path-noscheme = segment-nz-nc *( "/" segment )
//     path-rootless = segment-nz *( "/" segment )
//     path-empty    = 0<pchar>
//
//     segment       = *pchar
//     segment-nz    = 1*pchar
//     segment-nz-nc = 1*( unreserved / pct-encoded / sub-delims / "@" )
//                   ; non-zero-length segment without any colon ":"
//
//     pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"
//
//     reserved      = gen-delims / sub-delims
//     gen-delims    = ":" / "/" / "?" / "#" / "[" / "]" / "@"
//     sub-delims    = "!" / "$" / "&" / "'" / "(" / ")" / "*" / "+" / "," / ";" / "="
//
// A URI-reference is either a URI or a relative reference.  If the
// URI-reference's prefix does not match the syntax of a scheme followed
// by its colon separator, then the URI-reference is a relative
// reference.
//
// A URI-reference is typically parsed first into the five URI
// components, in order to determine what components are present and
// whether the reference is relative. Then, each component is parsed
// for its subparts and their validation.
//
//
// Relative Reference
// -----------------------------------------------
// A relative reference takes advantage of the hierarchical syntax
// to express a URI reference relative to the name space of another
// hierarchical URI.
//
//     relative-ref  = relative-part [ "?" query ] [ "#" fragment ]
//
//     relative-part = "//" authority path-abempty
//                   / path-absolute
//                   / path-noscheme
//                   / path-empty
//
//     path          = path-abempty    ; begins with "/" or is empty
//                   / path-absolute   ; begins with "/" but not "//"
//                   / path-noscheme   ; begins with a non-colon segment
//                   / path-rootless   ; begins with a segment
//                   / path-empty      ; zero characters
//
//     path-abempty  = *( "/" segment )
//     path-absolute = "/" [ segment-nz *( "/" segment ) ]
//     path-noscheme = segment-nz-nc *( "/" segment )
//     path-rootless = segment-nz *( "/" segment )
//     path-empty    = 0<pchar>
//
//     segment       = *pchar
//     segment-nz    = 1*pchar
//     segment-nz-nc = 1*( unreserved / pct-encoded / sub-delims / "@" )
//                   ; non-zero-length segment without any colon ":"
//
//     pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"
//
//     reserved      = gen-delims / sub-delims
//     gen-delims    = ":" / "/" / "?" / "#" / "[" / "]" / "@"
//     sub-delims    = "!" / "$" / "&" / "'" / "(" / ")" / "*" / "+" / "," / ";" / "="
//
// The URI referred to by a relative reference, also known as the target
// URI, is obtained by applying the reference resolution algorithm of section "Reference Resolution".
//
// A relative reference that begins with two slash characters is termed
// a network-path reference; such references are rarely used.  A
// relative reference that begins with a single slash character is
// termed an absolute-path reference. A relative reference that does
// not begin with a slash character is termed a relative-path reference.
//
// A path segment that contains a colon character (e.g., "this:that")
// cannot be used as the first segment of a relative-path reference, as
// it would be mistaken for a scheme name.  Such a segment must be
// preceded by a dot-segment (e.g., "./this:that") to make a relative-
// path reference.
//
//
// Absolute URI
// -----------------------------------------------
// Some protocol elements allow only the absolute form of a URI without
// a fragment identifier.  For example, defining a base URI for later
// use by relative references calls for an absolute-URI syntax rule that
// does not allow a fragment.
//
//     absolute-URI  = scheme ":" hier-part [ "?" query ]
//
//
// Same-Document Reference
// -----------------------------------------------
// When a URI reference refers to a URI that is, aside from its fragment
// component (if any), identical to the base URI, that reference is called
// a "same-document" reference. The most frequent examples of same-document
// references are relative references that are empty or include only the number
// sign ("#") separator followed by a fragment identifier.
//
// When a same-document reference is dereferenced for a retrieval
// action, the target of that reference is defined to be within the same
// entity (representation, document, or message) as the reference;
// therefore, a dereference should not result in a new retrieval action.
//
// Normalization of the base and target URIs prior to their comparison,
// is allowed but rarely performed in practice. Normalization may increase
// the set of same-document references, which may be of benefit to some caching
// applications. As such, reference authors should not assume that a slightly
// different, though equivalent, reference URI will (or will not) be interpreted
// as a same-document reference by any given application.
//
//
// Suffix Reference
// -----------------------------------------------
// The URI syntax is designed for unambiguous reference to resources and
// extensibility via the URI scheme.  However, as URI identification and
// usage have become commonplace, traditional media (television, radio,
// newspapers, billboards, etc.) have increasingly used a suffix of the
// URI as a reference, consisting of only the authority and path
// portions of the URI, such as
//
//     www.w3.org/Addressing/
//
// or simply a DNS registered name on its own.  Such references are
// primarily intended for human interpretation rather than for machines,
// with the assumption that context-based heuristics are sufficient to
// complete the URI (e.g., most registered names beginning with "www"
// are likely to have a URI prefix of "http://").  Although there is no
// standard set of heuristics for disambiguating a URI suffix, many
// client implementations allow them to be entered by the user and
// heuristically resolved.
//
// Although this practice of using suffix references is common, it
// should be avoided whenever possible and should never be used in
// situations where long-term references are expected.  The heuristics
// noted above will change over time, particularly when a new URI scheme
// becomes popular, and are often incorrect when used out of context.
// Furthermore, they can lead to security issues.
//
// As a URI suffix has the same syntax as a relative-path reference, a
// suffix reference cannot be used in contexts where a relative
// reference is expected.  As a result, suffix references are limited to
// places where there is no defined base URI, such as dialog boxes and
// off-line advertisements.
//
//
// Reference Resolution
// -----------------------------------------------
// This section defines the process of resolving a URI reference within
// a context that allows relative references so that the result is a
// string matching the <URI> syntax rule.
//
//
// Establishing a Base URI
// -----------------------------------------------
// The term "relative" implies that a "base URI" exists against which
// the relative reference is applied. Aside from fragment-only references,
// relative references are only usable when a base URI is known. A base URI
// must be established by the parser prior to parsing URI references that might
// be relative. A base URI must conform to the <absolute-URI>
//
//     absolute-URI  = scheme ":" hier-part [ "?" query ]
//
// If the base URI is obtained from a URI reference, then that reference must
// be converted to absolute form and stripped of any fragment component
// prior to its use as a base URI.
//
// The base URI of a reference can be established in one of four ways,
// discussed below in order of precedence. The order of precedence can
// be thought of in terms of layers, where the innermost defined base
// URI has the highest precedence.  This can be visualized graphically
// as follows:
//
// .----------------------------------------------------------.
// |  .----------------------------------------------------.  |
// |  |  .----------------------------------------------.  |  |
// |  |  |  .----------------------------------------.  |  |  |
// |  |  |  |  .----------------------------------.  |  |  |  |
// |  |  |  |  |       <relative-reference>       |  |  |  |  |
// |  |  |  |  `----------------------------------'  |  |  |  |
// |  |  |  |         Base URI embedded in content   |  |  |  |
// |  |  |  `----------------------------------------'  |  |  |
// |  |  |         Base URI of the encapsulating entity |  |  |
// |  |  |         (message, representation, or none)   |  |  |
// |  |  `----------------------------------------------'  |  |
// |  |         URI used to retrieve the entity            |  |
// |  `----------------------------------------------------'  |
// |         Default Base URI (application-dependent)         |
// `----------------------------------------------------------'
//
//
// Base URI Embedded in Content
// -----------------------------------------------
// Within certain media types, a base URI for relative references can be
// embedded within the content itself so that it can be readily obtained
// by a parser.  This can be useful for descriptive documents, such as
// tables of contents, which may be transmitted to others through
// protocols other than their usual retrieval context (e.g., email or
// USENET news).

// It is beyond the scope of this specification to specify how, for each
// media type, a base URI can be embedded.  The appropriate syntax, when
// available, is described by the data format specification associated
// with each media type.
//
//
// Base URI from the Encapsulating Entity
// -----------------------------------------------
// If no base URI is embedded, the base URI is defined by the
// representation's retrieval context.  For a document that is enclosed
// within another entity, such as a message or archive, the retrieval
// context is that entity.  Thus, the default base URI of a
// representation is the base URI of the entity in which the
// representation is encapsulated.
//
// A mechanism for embedding a base URI within MIME container types
// (e.g., the message and multipart types) is defined by MHTML.
// Protocols that do not use the MIME message header syntax,
// but that do allow some form of tagged metadata to be included within
// messages, may define their own syntax for defining a base URI as part
// of a message.
//
//
// Base URI from the Retrieval URI
// -----------------------------------------------
// If no base URI is embedded and the representation is not encapsulated
// within some other entity, then, if a URI was used to retrieve the
// representation, that URI shall be considered the base URI.  Note that
// if the retrieval was the result of a redirected request, the last URI
// used (i.e., the URI that resulted in the actual retrieval of the
// representation) is the base URI.
//
//
// Default Base URI
// -----------------------------------------------
// If none of the conditions described above apply, then the base URI is
// defined by the context of the application. As this definition is
// necessarily application-dependent, failing to define a base URI by
// using one of the other methods may result in the same content being
// interpreted differently by different types of applications.
//
// A sender of a representation containing relative references is
// responsible for ensuring that a base URI for those references can be
// established. Aside from fragment-only references, relative
// references can only be used reliably in situations where the base URI
// is well defined.
//
//
// Relative Resolution
// -----------------------------------------------
// This section describes an algorithm for converting a URI reference
// that might be relative to a given base URI into the parsed components
// of the reference's target. The components can then be recomposed, as
// described in "Component Recomposition" to form the target URI. This
// algorithm provides definitive results that can be used to test the output of
// other implementations. Applications may implement relative reference
// resolution by using some other algorithm, provided that the results
// match what would be given by this one.
//
//
// Pre-parse the Base URI
// -----------------------------------------------
// The base URI (Base) is established according to the procedure of "Establishing a Base URI"
// and parsed into the five main components described in "Syntax Components". Note that only
// the scheme component is required to be present in a base URI; the other components may be empty or
// undefined. A component is undefined if its associated delimiter does not appear in the URI reference;
// the path component is never undefined, though it may be empty.
//
// Normalization of the base URI, as described in Sections "Syntax-Based Normalization" and
// "Scheme-Based Normalization", is optional. A URI reference must be transformed to its
// target URI before it can be normalized.
//
//
// Transform References
// -----------------------------------------------
// For each URI reference (R), the following pseudocode describes an
// algorithm for transforming R into its target URI (T):
//
//     -- The URI reference is parsed into the five URI components
//     --
//     (R.scheme, R.authority, R.path, R.query, R.fragment) = parse(R);
//
//     -- A non-strict parser may ignore a scheme in the reference
//     -- if it is identical to the base URI's scheme.
//     --
//     if ((not strict) and (R.scheme == Base.scheme)) then
//         undefine(R.scheme);
//     endif;
//     if defined(R.scheme) then
//         T.scheme    = R.scheme;
//         T.authority = R.authority;
//         T.path      = remove_dot_segments(R.path);
//         T.query     = R.query;
//     else
//         if defined(R.authority) then
//             T.authority = R.authority;
//             T.path      = remove_dot_segments(R.path);
//             T.query     = R.query;
//         else
//             if (R.path == "") then
//                 T.path = Base.path;
//                 if defined(R.query) then
//                     T.query = R.query;
//                 else
//                     T.query = Base.query;
//                 endif;
//             else
//                 if (R.path starts-with "/") then
//                     T.path = remove_dot_segments(R.path);
//                 else
//                     T.path = merge(Base.path, R.path);
//                     T.path = remove_dot_segments(T.path);
//                 endif;
//                 T.query = R.query;
//             endif;
//             T.authority = Base.authority;
//         endif;
//         T.scheme = Base.scheme;
//     endif;
//
// T.fragment = R.fragment;
//
//
// Merge Paths
// -----------------------------------------------
// The pseudocode above refers to a "merge" routine for merging a
// relative-path reference with the path of the base URI. This is
// accomplished as follows:
//     - If the base URI has a defined authority component and an empty
//       path, then return a string consisting of "/" concatenated with the
//       reference's path; otherwise,
//
//     - return a string consisting of the reference's path component
//       appended to all but the last segment of the base URI's path (i.e.,
//       excluding any characters after the right-most "/" in the base URI
//       path, or excluding the entire base URI path if it does not contain
//       any "/" characters).
//
//
// Remove Dot Segments
// -----------------------------------------------
// The pseudocode also refers to a "remove_dot_segments" routine for
// interpreting and removing the special "." and ".." complete path
// segments from a referenced path.
//
// https://www.rfc-editor.org/rfc/rfc3986#section-5.2.4

TODO!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!