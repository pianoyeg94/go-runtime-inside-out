// mksyscall.pl -tags linux,amd64 syscall_linux.go syscall_linux_amd64.go
// Code generated by the command above; DO NOT EDIT.

//go:build linux && amd64

package heap

import "syscall"

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func mmap(addr uintptr, length uintptr, prot int, flags int, fd int, offset int64) (xaddr uintptr, err error) {
	r0, _, e1 := syscall.Syscall6(syscall.SYS_MMAP,
		uintptr(addr),
		uintptr(length),
		uintptr(prot),
		uintptr(flags),
		uintptr(fd),
		uintptr(offset),
	)

	xaddr = uintptr(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}

	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func munmap(addr uintptr, length uintptr) (err error) {
	// The munmap() system call deletes the mappings for the specified
	// address range, and causes further references to addresses within
	// the range to generate invalid memory references.  The region is
	// also automatically unmapped when the process is terminated.  On
	// the other hand, closing the file descriptor does not unmap the
	// region.

	// The address addr must be a multiple of the page size (but length
	// need not be).  All pages containing a part of the indicated range
	// are unmapped, and subsequent references to these pages will
	// generate SIGSEGV.  It is not an error if the indicated range does
	// not contain any mapped pages.
	_, _, e1 := syscall.Syscall(syscall.SYS_MUNMAP, uintptr(addr), uintptr(length), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}
